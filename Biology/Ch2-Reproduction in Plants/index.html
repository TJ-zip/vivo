<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Supreme HTML Quiz</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        /* ... (your existing CSS rules) ... */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrollbars on body */
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            background-color: #f0f2f5;
            color: #333;
            font-size: 16px;
            display: flex;
            flex-direction: column;
        }

        .quiz-container, .landing-container, .results-container {
            background-color: #ffffff;
            overflow: hidden;
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .landing-container, .results-container {
            padding: 30px;
            text-align: center;
            justify-content: center;
            align-items: center;
            overflow-y: auto;
            box-sizing: border-box;
        }
        .results-container {
            justify-content: flex-start; /* Align results content to top */
        }


        .landing-container h1, .results-container h1 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 2em;
            font-weight: 600;
            margin-top: 0;
        }

        .landing-container input[type="text"] {
            padding: 10px 12px;
            margin-bottom: 20px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 80%;
            max-width: 300px;
            font-size: 1em;
        }

        .start-button, .nav-button, .review-button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s ease;
            margin: 5px;
            font-weight: 500;
        }

        .start-button:hover, .nav-button:hover, .review-button:hover {
            background-color: #0056b3;
        }

        .quiz-header {
            background-color: #343a40;
            color: white;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            height: 48px; /* Fixed height */
            box-sizing: border-box;
        }

        .quiz-header h1 {
            margin: 0;
            font-size: 1.5em;
            font-weight: 600;
        }

        .user-info {
            font-size: 0.95em;
        }

        .quiz-body {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
            height: calc(100vh - 48px); /* Full height minus header */
        }

        .question-nav {
            width: 200px;
            background-color: #f8f9fa;
            padding: 15px;
            border-right: 1px solid #dee2e6;
            overflow-y: auto;
            flex-shrink: 0;
            height: 100%;
            box-sizing: border-box;
        }

        .question-nav h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #495057;
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 8px;
            font-size: 1.1em;
            font-weight: 600;
        }

        .question-nav-list {
            list-style-type: none;
            padding: 0;
            margin: 0;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(35px, 1fr));
            gap: 8px;
        }

        .question-nav-item {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 35px;
            height: 35px;
            border: 1px solid #adb5bd;
            border-radius: 50%;
            cursor: pointer;
            font-weight: normal;
            background-color: #ffffff;
            color: #495057;
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
            position: relative;
            font-size: 0.9em;
        }

        .question-nav-item:hover {
            background-color: #e9ecef;
        }

        /* Status Colors */
        .question-nav-item.status-default { background-color: #ffffff; color: #495057; border-color: #adb5bd;} /* White */
        .question-nav-item.status-answered { background-color: #28a745; color: white; border-color: #218838; } /* Green */
        .question-nav-item.status-unanswered { background-color: #dc3545; color: white; border-color: #c82333; } /* Red */
        .question-nav-item.status-review { background-color: #6f42c1; color: white; border-color: #5a32a3; } /* Purple */
        .question-nav-item.status-answered-review { background-color: #6f42c1; color: white; border-color: #5a32a3; } /* Purple + Green Dot */

        /* Green dot for answered and reviewed */
        .question-nav-item.status-answered-review::after {
            content: '';
            position: absolute;
            top: 2px;
            right: 2px;
            width: 7px;
            height: 7px;
            background-color: #28a745; /* Green dot */
            border-radius: 50%;
            border: 1px solid white;
        }


        .main-content {
            flex-grow: 1;
            padding: 25px;
            display: flex;
            flex-direction: column;
            /* justify-content: space-between; REMOVED - Let content flow naturally */
            overflow-y: auto; /* Allow scrolling for the whole main area */
            height: 100%;
            box-sizing: border-box;
        }

        .timers {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            font-size: 1em;
            font-weight: 500;
            color: #495057;
            flex-shrink: 0;
        }

        .timer {
            background-color: #e9ecef;
            padding: 6px 12px;
            border-radius: 4px;
            border: 1px solid #ced4da;
        }
        .timer.red {
            color: #dc3545;
            border-color: #dc3545;
            font-weight: 600;
        }

        .question-area-wrapper { /* Wrapper for question and options */
             /* Allow this area to take up available space before buttons */
             flex-grow: 1;
             margin-bottom: 20px; /* Space before buttons */
             /* Removed overflow-y: auto; let main-content handle scrolling */
        }

        .question-text {
            font-size: 1.2em;
            margin-bottom: 20px;
            line-height: 1.5;
            color: #212529;
            font-weight: 500;
        }

        /* --- Image Container Styling --- */
        #question-image-container {
             margin-bottom: 20px; /* Space between image and options */
             text-align: center; /* Center the image */
        }
        #question-image-container img {
             max-width: 100%; /* Make image responsive */
             height: auto;    /* Maintain aspect ratio */
             max-height: 300px; /* Optional: Limit max height */
             border-radius: 4amma; /* Optional: Rounded corners */
             box-shadow: 0 2px 4px rgba(0,0,0,0.1); /* Optional: Slight shadow */
        }
         /* --- END NEW --- */

        .options {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }

        .options li {
            margin-bottom: 10px;
        }

        .options label {
            display: block;
            background-color: #f8f9fa;
            border: 1px solid #ced4da;
            padding: 12px 15px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
            font-size: 1em;
            font-weight: normal;
        }

        .options input[type="radio"] {
            margin-right: 10px;
            display: none;
        }

         .options label:hover {
             background-color: #e2e6ea;
             border-color: #adb5bd;
         }

        .options input[type="radio"]:checked + label {
            background-color: #cfe2ff;
            border-color: #007bff;
            font-weight: 500;
            color: #0056b3;
        }


        .navigation-buttons {
            display: flex;
            justify-content: space-between;
            border-top: 1px solid #dee2e6;
            padding-top: 15px;
            /* margin-top: auto; REMOVED - Let it sit naturally at the bottom */
            flex-shrink: 0; /* Prevent buttons area from shrinking */
        }

        .nav-button.prev { background-color: #ffc107; color: #212529;}
        .nav-button.prev:hover { background-color: #e0a800; }
        .review-button { background-color: #6f42c1; }
        .review-button:hover { background-color: #5a32a3; }
        .nav-button.next { background-color: #28a745; }
        .nav-button.next:hover { background-color: #218838; }
        .nav-button:disabled {
            background-color: #adb5bd;
            cursor: not-allowed;
            opacity: 0.7;
        }
        .nav-button.submit { background-color: #dc3545; }
        .nav-button.submit:hover { background-color: #c82333; }


        /* Results Page Specifics */
        .results-content {
             width: 100%;
             max-width: 900px;
             margin: 0 auto;
             padding: 20px 0;
        }

        .score-card {
            background-color: #e6f7ff;
            border: 1px solid #007bff;
            padding: 15px 20px;
            margin-bottom: 25px;
            border-radius: 5px;
        }
        .score-card h2 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #0056b3;
            font-size: 1.5em;
            font-weight: 600;
        }
        .score-card p {
            font-size: 1.2em;
            font-weight: 500;
            color: #343a40;
            margin: 5px 0;
        }

        .results-section {
            margin-bottom: 25px;
            text-align: left;
            padding: 15px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
        }

        .results-section h3 {
            color: #495057;
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 8px;
            margin-bottom: 15px;
            font-size: 1.2em;
            font-weight: 600;
        }

        .result-item {
            border-bottom: 1px dashed #ced4da;
            padding: 12px 0;
        }
        .result-item:last-child {
            border-bottom: none;
        }
        .result-item p {
            margin: 4px 0;
            font-size: 1em;
            line-height: 1.4;
        }
        .result-item .question { font-weight: 600; color: #343a40; }
        .result-item .your-answer { color: #dc3545; font-weight: 500;}
        .result-item .correct-answer { color: #28a745; font-weight: 500;}
        .result-item .explanation { font-style: normal; color: #6c757d; margin-top: 8px; font-size: 0.95em;}

        .time-analysis {
             padding: 15px;
             background-color: #f8f9fa;
             border: 1px solid #dee2e6;
             border-radius: 5px;
             margin-bottom: 20px;
        }
        .time-analysis h3 {
             color: #495057;
             border-bottom: 1px solid #dee2e6;
             padding-bottom: 8px;
             margin-bottom: 15px;
             text-align: left;
             font-size: 1.2em;
             font-weight: 600;
        }
        #timeChart {
            max-height: 350px;
            width: 100% !important;
        }

        /* Hide elements */
        .hidden {
            display: none !important;
        }

    </style>
</head>
<body>

    <!-- Landing Page -->
    <div id="landing-page" class="landing-container">
        <h1>Welcome to the Quiz!</h1>
        <input type="text" id="name-input" placeholder="Enter your name">
        <br>
        <button id="start-quiz-button" class="start-button">Start Quiz</button>
    </div>

    <!-- Quiz Page -->
    <div id="quiz-page" class="quiz-container hidden">
        <div class="quiz-header">
            <h1>Quiz</h1>
            <div class="user-info">
                <span>Name: <span id="user-name"></span></span> |
                <span>Total Time Left: <span id="total-timer">05:00</span></span>
            </div>
        </div>
        <div class="quiz-body">
            <div class="question-nav">
                <h3>Question Palette</h3>
                <ul id="question-nav-list" class="question-nav-list">
                    <!-- Question numbers will be dynamically added here -->
                </ul>
            </div>
            <div class="main-content">
                <!-- Top content wrapper -->
                <div class="timers">
                    <span id="current-question-number">Question X of Y</span>
                    <span class="timer" id="question-timer">Time: 0s</span>
                </div>
                <!-- Scrollable question area -->
                <div class="question-area-wrapper">
                    <p id="question-text" class="question-text">Question text goes here...</p>
                    <!-- === Image container === -->
                    <div id="question-image-container"></div>
                    <!-- === END NEW === -->
                    <ul id="options-list" class="options">
                        <!-- Options will be dynamically added here -->
                    </ul>
                </div>
                 <!-- Navigation buttons at the bottom -->
                <div class="navigation-buttons">
                    <button id="prev-button" class="nav-button prev">Previous</button>
                    <button id="review-button" class="review-button">Mark for Review</button>
                    <button id="next-button" class="nav-button next">Next</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Results Page -->
    <div id="results-page" class="results-container hidden">
       <div class="results-content">
            <h1>Quiz Results</h1>
            <div id="score-card" class="score-card">
                <h2>Score</h2>
                <p><span id="score">0</span> / <span id="total-marks">0</span></p>
                 <p>Well done, <span id="result-user-name">User</span>!</p>
            </div>

            <div id="wrong-unanswered-list" class="results-section">
                <h3>Review Incorrect & Unanswered Questions</h3>
                <!-- Incorrect/Unanswered questions will be added here -->
            </div>

            <div class="time-analysis">
                 <h3>Time Analysis Per Question</h3>
                <canvas id="timeChart"></canvas>
            </div>
             <button onclick="window.location.reload();" class="start-button">Restart Quiz</button>
        </div>
    </div>

    <script>
                const quizData = [
            {
                question: "Pollen is produced in the:",
                options: ["Filament", "Style", "Anther", "Pistil"],
                answer: "Anther",
                explanation: "The anther is the part of the stamen that contains the pollen."
            },
            {
                question: "The reproductive whorls of a flower are:",
                options: ["Sepals and petals", "Stamens and carpels", "Sepals and stamens", "Petals and carpels"],
                answer: "Stamens and carpels",
                explanation: "The stamens (male part) and carpels/pistil (female part) are the essential reproductive parts of a flower. Sepals and petals are accessory whorls."
            },
            {
                question: "Grafting is a method of:",
                options: ["Sexual reproduction", "Cross-pollination", "Artificial pollination", "Artificial vegetative propagation"],
                answer: "Artificial vegetative propagation",
                explanation: "Grafting is a horticultural technique used to join parts from two or more plants so that they appear to grow as a single plant."
            },
            {
                question: "Which of the following is an example of a 'false fruit'?",
                options: ["Mango", "Apple", "Grape", "Banana"],
                answer: "Apple",
                explanation: "In a false fruit like an apple, the fleshy part develops from the thalamus, not the ovary."
            },
            {
                question: "Flowers that are pollinated by insects are typically:",
                options: ["Small and scentless", "Large, colourful, and scented", "Producing light pollen in small amounts", "Lacking petals"],
                answer: "Large, colourful, and scented",
                explanation: "These features are adaptations to attract insects, which act as pollinators."
            },
            {
                question: "Which of these is a key characteristic of wind-pollinated flowers?",
                options: ["They produce nectar", "They have sticky stigmas", "They produce large quantities of light pollen", "They have brightly coloured petals"],
                answer: "They produce large quantities of light pollen",
                explanation: "This increases the chances that the wind will carry the pollen to another flower."
            },
            {
                question: "A flower that bears both the male and the female parts is known as a __________ flower.",
                options: ["unisexual", "bisexual", "sterile", "complete"],
                answer: "bisexual",
                explanation: "Bisexual (or perfect) flowers contain both male (stamen) and female (pistil) reproductive organs."
            },
            {
                question: "Transfer of pollen grains from the anther to the stigma is known as __________.",
                options: ["fertilisation", "germination", "pollination", "dispersal"],
                answer: "pollination",
                explanation: "This is the definition of pollination, the first step in sexual reproduction in flowering plants."
            },
            {
                question: "A flower bearing only male or female parts is known as a __________ flower.",
                options: ["bisexual", "complete", "unisexual", "perfect"],
                answer: "unisexual",
                explanation: "Unisexual (or imperfect) flowers have either male or female parts, but not both."
            },
            {
                question: "The fusion of the male cell with the female cell is called __________.",
                options: ["pollination", "fertilisation", "germination", "propagation"],
                answer: "fertilisation",
                explanation: "Fertilisation is the process where the male gamete fuses with the female gamete (in the ovule) to form a zygote."
            },
            {
                question: "After fertilization, the ovule develops into a __________.",
                options: ["fruit", "seed", "flower", "embryo sac"],
                answer: "seed",
                explanation: "After successful fertilization, the ovule matures and develops into a seed."
            },
            {
                question: "After fertilization, the ovary of the flower develops into a __________.",
                options: ["seed", "flower", "fruit", "embryo"],
                answer: "fruit",
                explanation: "The ovary of the flower develops and ripens to become the fruit, which encloses the seed(s)."
            },
            {
                question: "What are two main ways pollination can occur in plants?",
                options: ["Wind and water", "Insects and animals", "Self-pollination and cross-pollination", "Grafting and budding"],
                answer: "Self-pollination and cross-pollination",
                explanation: "Self-pollination is the transfer of pollen within the same flower or to another flower on the same plant. Cross-pollination is the transfer of pollen to a flower on a different plant."
            },
            {
                question: "Which group contains common agents of pollination?",
                options: ["Wind, Water, Sunlight", "Insects, Birds, Soil", "Wind, Water, Animals", "Temperature, Gravity, Minerals"],
                answer: "Wind, Water, Animals",
                explanation: "Insects, Wind, and Water are the three main agents that carry pollen from one flower to another. Animals (including birds, bats etc.) are also significant agents."
            },
            {
                question: "Which features favour pollination by insects?",
                options: ["Small size and no scent", "Producing large quantities of light pollen", "Large size, coloured petals, and scent", "Lacking petals and scent"],
                answer: "Large size, coloured petals, and scent",
                explanation: "Bright colours visually attract insects, and scents help them locate the flowers from a distance."
            },
            {
                question: "Which characteristics are typical of wind-pollinated flowers?",
                options: ["Heavy, sticky pollen", "Brightly coloured petals and nectar", "Producing light pollen in large quantities", "Having fused petals"],
                answer: "Producing light pollen in large quantities",
                explanation: "The pollen must be light to be carried by air currents, and large quantities are produced to ensure some reaches its target."
            },
            {
                question: "What best describes a 'false fruit'?",
                options: ["A fruit with no seeds", "A fruit where the fleshy part develops from the thalamus", "A fruit that develops from the fertilised ovary wall", "A fruit that is eaten before ripening"],
                answer: "A fruit where the fleshy part develops from the thalamus",
                explanation: "In a false fruit, the main fleshy part develops from the thalamus (base of the flower) instead of the ovary. Example: Apple or Pear."
            },
            {
                question: "Which group lists common agencies for the dispersal of seeds?",
                options: ["Pollen, Nectar, Petals", "Wind, Water, Animals", "Roots, Stems, Leaves", "Sepals, Stamens, Carpels"],
                answer: "Wind, Water, Animals",
                explanation: "These agencies help carry seeds away from the parent plant, reducing competition and colonizing new areas."
            }
        ];

        // Apply Fisher-Yates (Knuth) Shuffle function
        function fisherYatesShuffle(array) {
            let currentIndex = array.length, randomIndex;

            // While there remain elements to shuffle.
            while (currentIndex != 0) {

                // Pick a remaining element.
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;

                // And swap it with the current element.
                [array[currentIndex], array[randomIndex]] = [
                    array[randomIndex], array[currentIndex]];
            }

            return array;
        }

        // Shuffle the options WITHIN each question
        quizData.forEach(question => {
            fisherYatesShuffle(question.options);
             // The correct answer text remains the same, but its position in the options array has changed.
             // The existing comparison logic (userAnswer === question.answer) works correctly with this.
        });

        // Apply Fisher-Yates (Knuth) Shuffle to randomize the order of questions
        fisherYatesShuffle(quizData);


        // --- State Variables ---
        // Initialize state variables AFTER quizData is defined and shuffled
        let currentQuestionIndex = 0;
        // User answers and other state variables need to be sized based on the (now potentially reordered) quizData
        let userAnswers = new Array(quizData.length).fill(null);
        let questionStatus = new Array(quizData.length).fill('default');
        let markedForReview = new Array(quizData.length).fill(false);
        let timeSpentPerQuestion = new Array(quizData.length).fill(0);
        let questionTimerInterval;
        let totalTimerInterval;
        let questionViewStartTime = null;
        let totalTimeSeconds = 5 * 60; // Total time for the quiz
        let userName = "";
        let timeChart = null;
        const QUESTION_TIME_LIMIT = 45; // Time limit marker for chart

        // --- DOM Elements ---
        const landingPage = document.getElementById('landing-page');
        const quizPage = document.getElementById('quiz-page');
        const resultsPage = document.getElementById('results-page');
        const nameInput = document.getElementById('name-input');
        const startQuizButton = document.getElementById('start-quiz-button');
        const userNameDisplay = document.getElementById('user-name');
        const resultUserNameDisplay = document.getElementById('result-user-name');
        const totalTimerDisplay = document.getElementById('total-timer');
        const questionNavList = document.getElementById('question-nav-list');
        const currentQuestionNumberDisplay = document.getElementById('current-question-number');
        const questionTimerDisplay = document.getElementById('question-timer');
        const questionText = document.getElementById('question-text');
        const optionsList = document.getElementById('options-list');
        const prevButton = document.getElementById('prev-button');
        const reviewButton = document.getElementById('review-button');
        const nextButton = document.getElementById('next-button');
        const scoreDisplay = document.getElementById('score');
        const totalMarksDisplay = document.getElementById('total-marks');
        const wrongUnansweredList = document.getElementById('wrong-unanswered-list');
        const timeChartCanvas = document.getElementById('timeChart');
        const imageContainer = document.getElementById('question-image-container');

        // --- Functions ---

        function showPage(pageId) {
            landingPage.classList.add('hidden');
            quizPage.classList.add('hidden');
            resultsPage.classList.add('hidden');
            const pageToShow = document.getElementById(pageId);
            if (pageToShow) {
                pageToShow.classList.remove('hidden');
            }
        }

        function startQuiz() {
            userName = nameInput.value.trim() || "Guest";
            userNameDisplay.textContent = userName;
            resultUserNameDisplay.textContent = userName;
            showPage('quiz-page');

            totalMarksDisplay.textContent = quizData.length;
            // Re-initialize state arrays based on the now-shuffled quizData length
            userAnswers = new Array(quizData.length).fill(null);
            questionStatus = new Array(quizData.length).fill('default');
            markedForReview = new Array(quizData.length).fill(false);
            timeSpentPerQuestion = new Array(quizData.length).fill(0);

            initializeQuestionNav();
            loadQuestion(currentQuestionIndex);
            startTotalTimer();
        }

        function initializeQuestionNav() {
            questionNavList.innerHTML = '';
            quizData.forEach((_, index) => {
                const li = document.createElement('li');
                li.textContent = index + 1; // Display sequential number (1-based)
                li.classList.add('question-nav-item', `status-${questionStatus[index]}`);
                li.dataset.index = index; // Store actual index
                li.addEventListener('click', () => navigateToQuestion(index));
                questionNavList.appendChild(li);
            });
             updateQuestionNavHighlight();
        }

        function updateQuestionNavHighlight() {
             const items = questionNavList.querySelectorAll('.question-nav-item');
             items.forEach((item, index) => {
                 item.style.borderColor = '';
                 item.style.borderWidth = '';
                 if (index === currentQuestionIndex) {
                     item.style.borderColor = '#007bff';
                     item.style.borderWidth = '2px';
                 }
             });
        }


        function updateSingleQuestionNavStatus(index) {
            // Find the nav item by its data-index attribute, which matches the array index
            const item = questionNavList.querySelector(`.question-nav-item[data-index="${index}"]`);
            if (item) {
                item.classList.remove('status-default', 'status-answered', 'status-unanswered', 'status-review', 'status-answered-review');
                item.classList.add(`status-${questionStatus[index]}`);
            }
        }

        function recordTimeSpent() {
            if (questionViewStartTime !== null) {
                const timeElapsedThisVisit = (Date.now() - questionViewStartTime) / 1000;
                if (timeElapsedThisVisit > 0) {
                    // Add time spent to the correct index in the timeSpentPerQuestion array
                    timeSpentPerQuestion[currentQuestionIndex] += timeElapsedThisVisit;
                }
                questionViewStartTime = null;
            }
        }

        function updateStatus(index) {
            const answered = userAnswers[index] !== null;
            const reviewed = markedForReview[index];
            let currentStatus = questionStatus[index];
            let newStatus = currentStatus; // Default to keeping current status

            if (answered && reviewed) {
                newStatus = 'answered-review';
            } else if (answered && !reviewed) {
                 // If it was unanswered-review and now answered, remove review
                 if (currentStatus === 'review' || currentStatus === 'answered-review') {
                     newStatus = 'answered';
                 } else {
                    newStatus = 'answered';
                 }
            } else if (!answered && reviewed) {
                 // If it was answered-review and now unmarked or answer removed
                 if (currentStatus === 'answered' || currentStatus === 'answered-review') {
                     newStatus = 'review';
                 } else {
                     newStatus = 'review';
                 }
            } else if (!answered && !reviewed) {
                 // If it was answered and now unmarked/answer removed
                 if (currentStatus === 'answered' || currentStatus === 'answered-review') {
                     newStatus = 'unanswered'; // Mark as unanswered if previously answered but now empty
                 } else if (currentStatus === 'review') {
                      newStatus = 'unanswered'; // Mark as unanswered if previously review but now empty
                 } else {
                      newStatus = 'default'; // Keep default if not answered and not reviewed initially
                 }
            }


            if (newStatus !== currentStatus) {
                questionStatus[index] = newStatus;
                updateSingleQuestionNavStatus(index);
            }
        }

        function finalizeStatusOnLeave(index) {
            const answered = userAnswers[index] !== null;
            const reviewed = markedForReview[index];
            let finalStatus = questionStatus[index]; // Start with current status

            if (answered && reviewed) {
                finalStatus = 'answered-review';
            } else if (answered && !reviewed) {
                finalStatus = 'answered';
            } else if (!answered && reviewed) {
                finalStatus = 'review';
            } else if (!answered && !reviewed) {
                finalStatus = 'unanswered'; // Mark as unanswered if not answered and not reviewed upon leaving
            }

            if (finalStatus !== questionStatus[index]) {
                questionStatus[index] = finalStatus;
            }
            updateSingleQuestionNavStatus(index);
        }


        function loadQuestion(index) {
            // Ensure index is within bounds
            if (index < 0 || index >= quizData.length) {
                console.error("Invalid question index:", index);
                return;
            }

            const question = quizData[index];
            currentQuestionNumberDisplay.textContent = `Question ${index + 1} of ${quizData.length}`;
            questionText.textContent = question.question;

            // --- Handle Image Display ---
            imageContainer.innerHTML = ''; // Clear previous image
            if (question.image) {
                const imgElement = document.createElement('img');
                imgElement.src = question.image;
                imgElement.alt = `Image for question ${index + 1}`; // Add alt text
                imageContainer.appendChild(imgElement);
            }
            // --- END Image Handling ---

            optionsList.innerHTML = '';
            question.options.forEach((option, i) => {
                const li = document.createElement('li');
                // Use question index and option index for unique IDs and names
                const inputId = `q${index}_option${i}`;
                const input = document.createElement('input');
                input.type = 'radio';
                input.name = `question${index}`; // Name attribute should group options per question index
                input.value = option;
                input.id = inputId;
                // Check if this option matches the user's saved answer for this question index
                input.checked = userAnswers[index] === option;
                input.addEventListener('change', () => {
                    // Save the selected option text to the userAnswers array at the correct index
                    userAnswers[index] = option;
                    updateStatus(index);
                });

                const label = document.createElement('label');
                label.htmlFor = inputId;
                label.textContent = option;

                li.appendChild(input);
                li.appendChild(label);
                optionsList.appendChild(li);
            });

            // Update button states
            prevButton.disabled = index === 0;
            nextButton.textContent = index === quizData.length - 1 ? 'Submit' : 'Next';
            nextButton.classList.toggle('submit', index === quizData.length - 1); // Add 'submit' class

            // Update review button state based on markedForReview array
            reviewButton.textContent = markedForReview[index] ? 'Unmark Review' : 'Mark for Review';
            // Appearance is now driven by CSS class via updateStatus -> updateSingleQuestionNavStatus
             reviewButton.classList.toggle('is-reviewed', markedForReview[index]);


            questionViewStartTime = Date.now();
            startQuestionTimer();

            updateQuestionNavHighlight();

            // Scroll to the top of the question area when loading a new question
            const questionAreaWrapper = document.querySelector('.question-area-wrapper');
            if (questionAreaWrapper) questionAreaWrapper.scrollTop = 0;
        }

        function navigateToQuestion(index) {
            // Only navigate if the index is valid and not the current question
            if (index < 0 || index >= quizData.length || index === currentQuestionIndex) return;

            const leavingIndex = currentQuestionIndex;
            recordTimeSpent(); // Record time for the question being left
            finalizeStatusOnLeave(leavingIndex); // Finalize status for the question being left

            currentQuestionIndex = index; // Update current index
            loadQuestion(currentQuestionIndex); // Load the new question
        }

        function handleNext() {
             const leavingIndex = currentQuestionIndex;
             recordTimeSpent(); // Record time before leaving
             finalizeStatusOnLeave(leavingIndex); // Finalize status before leaving

             if (currentQuestionIndex < quizData.length - 1) {
                currentQuestionIndex++;
                loadQuestion(currentQuestionIndex);
            } else {
                submitQuiz();
            }
        }

        function handlePrev() {
            const leavingIndex = currentQuestionIndex;
            recordTimeSpent(); // Record time before leaving
            finalizeStatusOnLeave(leavingIndex); // Finalize status before leaving

            if (currentQuestionIndex > 0) {
               currentQuestionIndex--;
               loadQuestion(currentQuestionIndex);
            }
        }

        function toggleReview() {
            // Toggle the markedForReview state for the current question index
            markedForReview[currentQuestionIndex] = !markedForReview[currentQuestionIndex];
            updateStatus(currentQuestionIndex); // Update the status based on the new review state
            // Update button text and appearance
            reviewButton.textContent = markedForReview[currentQuestionIndex] ? 'Unmark Review' : 'Mark for Review';
            // Appearance is now driven by CSS class via updateStatus -> updateSingleQuestionNavStatus
        }


        function startQuestionTimer() {
            clearInterval(questionTimerInterval);

            function updateTimerDisplay() {
                // Calculate time spent on the current question
                let totalTimeSpentSoFar = timeSpentPerQuestion[currentQuestionIndex] || 0; // Use || 0 for safety
                let timeElapsedThisVisit = 0;

                if (questionViewStartTime) {
                    timeElapsedThisVisit = (Date.now() - questionViewStartTime) / 1000;
                }

                let currentTotalTime = totalTimeSpentSoFar + timeElapsedThisVisit;
                let displayTime = Math.round(currentTotalTime);

                questionTimerDisplay.classList.remove('red'); // Remove red class initially

                if (currentTotalTime > QUESTION_TIME_LIMIT) {
                    let exceededTime = Math.round(currentTotalTime - QUESTION_TIME_LIMIT);
                    questionTimerDisplay.textContent = `Exceeded: ${exceededTime}s`;
                    questionTimerDisplay.classList.add('red'); // Add red class if limit exceeded
                } else {
                     questionTimerDisplay.textContent = `Time: ${displayTime}s`;
                }
            }

            updateTimerDisplay(); // Update immediately
            questionTimerInterval = setInterval(updateTimerDisplay, 1000); // Update every second
        }

        function startTotalTimer() {
            clearInterval(totalTimerInterval);
            let currentTime = totalTimeSeconds;

            totalTimerInterval = setInterval(() => {
                currentTime--;
                if (currentTime <= 0) {
                    clearInterval(totalTimerInterval);
                    totalTimerDisplay.textContent = '00:00';
                    alert("Time's up! Your quiz is being submitted.");
                    submitQuiz(); // Submit the quiz when time runs out
                } else {
                    const minutes = Math.floor(currentTime / 60);
                    const seconds = currentTime % 60;
                    totalTimerDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                }
            }, 1000);
        }

        function submitQuiz() {
            recordTimeSpent(); // Record time for the last question
            finalizeStatusOnLeave(currentQuestionIndex); // Finalize status for the last question
            clearInterval(questionTimerInterval); // Stop question timer
            clearInterval(totalTimerInterval); // Stop total timer

            // Ensure all statuses are finalized (especially for those not visited last)
             questionStatus.forEach((status, index) => {
                 // Skip the last visited one as it was just finalized
                 if (index !== currentQuestionIndex) {
                     finalizeStatusOnLeave(index);
                 }
             });


            calculateResults();
            showPage('results-page');
        }

        function calculateResults() {
            let score = 0;
            wrongUnansweredList.innerHTML = ''; // Clear previous results

            quizData.forEach((question, index) => {
                // Check correctness based on stored user answer text matching the correct answer text
                const isCorrect = userAnswers[index] !== null && userAnswers[index] === question.answer;
                if (isCorrect) {
                    score++;
                }

                // Add to review list if incorrect or unanswered
                if (userAnswers[index] === null || !isCorrect) {
                    const resultItem = document.createElement('div');
                    resultItem.classList.add('result-item');

                    const qText = document.createElement('p');
                    qText.classList.add('question');
                     // Show original question number (index + 1) as displayed in the nav
                    qText.innerHTML = `<strong>Q${index + 1}:</strong> ${question.question}`;
                    resultItem.appendChild(qText);

                    const yourAns = document.createElement('p');
                    yourAns.innerHTML = `<strong>Your Answer:</strong> `;
                    if (userAnswers[index] !== null) {
                         yourAns.innerHTML += `<span class="your-answer">${userAnswers[index]}</span>`;
                    } else {
                         yourAns.innerHTML += `<span class="your-answer">Not Answered</span>`;
                    }
                     resultItem.appendChild(yourAns);


                    const correctAns = document.createElement('p');
                    correctAns.innerHTML = `<strong>Correct Answer:</strong> <span class="correct-answer">${question.answer}</span>`;
                    resultItem.appendChild(correctAns);

                    if (question.explanation) {
                        const explanation = document.createElement('p');
                        explanation.classList.add('explanation');
                        explanation.textContent = question.explanation;
                        resultItem.appendChild(explanation);
                    }


                    wrongUnansweredList.appendChild(resultItem);
                }
            });

            scoreDisplay.textContent = score;
            totalMarksDisplay.textContent = quizData.length;

            // Generate the time analysis chart after a short delay to ensure elements are ready
            setTimeout(generateTimeChart, 100);
        }

         function generateTimeChart() {
            const ctx = timeChartCanvas.getContext('2d');
             if (!ctx) {
                console.error("Failed to get canvas context for time chart.");
                return;
            }
            const labels = quizData.map((_, index) => `Q${index + 1}`); // Labels based on question index
            const data = timeSpentPerQuestion.map(time => Math.round(time)); // Time spent data

            const normalColor = 'rgba(0, 123, 255, 0.3)';
            const exceededColor = 'rgba(220, 53, 69, 0.3)';
            const normalBorder = 'rgba(0, 123, 255, 1)';
            const exceededBorder = 'rgba(220, 53, 69, 1)';

            // Destroy previous chart instance if it exists
            if (timeChart) {
                timeChart.destroy();
            }

            try {
                timeChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: 'Time Spent (seconds)',
                                data: data,
                                fill: true,
                                tension: 0.3, // Smooth the line
                                segment: { // Color segments based on threshold
                                    borderColor: ctx => (ctx.p1.parsed.y > QUESTION_TIME_LIMIT) ? exceededBorder : normalBorder,
                                    backgroundColor: ctx => {
                                        const y1 = ctx.p0.parsed.y;
                                        const y2 = ctx.p1.parsed.y;
                                        return (y1 > QUESTION_TIME_LIMIT || y2 > QUESTION_TIME_LIMIT) ? exceededColor : normalColor;
                                    }
                                },
                                 pointBackgroundColor: ctx => data[ctx.dataIndex] > QUESTION_TIME_LIMIT ? exceededBorder : normalBorder,
                                 pointBorderColor: '#fff',
                                 pointHoverBackgroundColor: '#fff',
                                 pointHoverBorderColor: ctx => data[ctx.dataIndex] > QUESTION_TIME_LIMIT ? exceededBorder : normalBorder,

                            },
                            {
                                type: 'line', // Add a line for the threshold
                                label: `${QUESTION_TIME_LIMIT}s Threshold`,
                                data: Array(quizData.length).fill(QUESTION_TIME_LIMIT), // Constant line at the threshold
                                borderColor: 'rgba(220, 53, 69, 0.8)',
                                borderWidth: 2,
                                borderDash: [5, 5],
                                fill: false,
                                pointRadius: 0, // Hide points on the threshold line
                                pointHoverRadius: 0
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false, // Allow height to be set by CSS
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Time (seconds)'
                                }
                            },
                            x: {
                                 title: {
                                    display: true,
                                    text: 'Question Number'
                                }
                            }
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        if (context.datasetIndex === 1) return null; // Hide tooltip for threshold line
                                        let label = context.dataset.label || '';
                                        if (label) label += ': ';
                                        if (context.parsed.y !== null) label += context.parsed.y + 's';
                                        return label;
                                    }
                                }
                            }
                        },
                         interaction: { // Improve tooltip behavior
                            intersect: false,
                            mode: 'index',
                        },
                    }
                });
            } catch (error) {
                console.error("Chart.js error:", error);
            }
        }


        // --- Event Listeners ---
        startQuizButton.addEventListener('click', startQuiz);
        prevButton.addEventListener('click', handlePrev);
        nextButton.addEventListener('click', handleNext);
        reviewButton.addEventListener('click', toggleReview);

        // Allow starting quiz by pressing Enter in the name input
         nameInput.addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                event.preventDefault(); // Prevent default form submission if any
                startQuizButton.click();
            }
        });

        // --- Initial Setup ---
        showPage('landing-page');

    </script>

</body>
</html>
